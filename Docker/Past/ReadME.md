<center> <h1>Discovering Docker</h1> </center>

## 1. A Quick Introduction to Docker

*Note 1: To install Docker on your machine, you could use the following procedure: https://docs.docker.com/engine/install/ubuntu/.* 

*Note 2; Alternatively you could also use the procedure in this `install_docker.sh` script, but it is not guaranteed that it will work as expected...*

*Note 3: You could have to use `sudo` to use the different docker commands used in this practical exercise*

*Note 4: The Web Site deployed si based on a work proposed by: https://www.reseaucerta.org/*

**Q1. What is Docker? What are the benefits of such an approach?**

To answer this question, you could use the folliwing link: https://www.knowledgehut.com/blog/devops/why-use-docker

To check that Docker is correctly installed on your machine, you could use the following command:

```console
$ docker run hello-world
```

In  this command line:
  1. `docker` tells your operating system you are using the docker program
  2. `run` is one on the different subcommands offered by docker to create an run a docker container
  3. `hello-world` is used to indicated to docker that you are using a specific image that will be loaded in the container

### Basic Commands

Different simple command line are enabled using `docker`, you should try some of them:
  - To look for docker images in the Docker Hub, an example for ubuntu keyword: `docker search ubuntu` 
  - To download a pre-build image (debian stretch image here): `docker pull debian:stretch`
  - To see the list of available images: docker images
  - To run an interactive shell within a given container: `docker run -i -t debian:stretch /bin/bash`. In this command line, `-i` indicates that we want to start an interactive container, `-t` creates a pseudo-TTY that attaches stdin and stdout. `exit` should be used to quit a running docker container. **To quit a running interactive container, use the "exit" command**
  - To list all containers: `docker ps -a`; to list running containers `docker ps`
  - To indicate the name of a container (basically launched with an autogenerated name and ID): `docker run --name XXX -i -t  /bin/bash`
  - To directly run commands within a container: docker run -d debian:stretch /bin/sh -c "while true;\ do echo Hi; sleep 1; done"
  - To kill a container `docker kill XXX`
  - To run and stop a container: `$ JOB=$(docker run...) ; $ docker logs $JOB ; docker kill $JOB`
  - To remove a container: `docker stop XXX` + `docker rm XXX`
  - To start/restart a container: `docker (re)start XXX` 
  - To pass variables from your host to your image: `docker run -ti -e FOO=BAR debian:stretch` => Running `echo $FOO` within your container you should be able to see the expected result
  - To commit a new image: `docker commit containerName newImageName` (could be especially useful after installing some new packages within a basic docker image)
  - To locally save an image: `docker save Image Name tarFileName`
  - To load an image from a tarFile: `docker lad -i tarFileName`
  - Indicate the memory that can be used by a container: `docker run -it -m 2GB...`
  - To dee diffications betweeb docker image and docker container: `docker diff dockerName`
  - To see running processes in a container: `docker top dockerName`
  - To map ports: `docker run -d -p machinePort:containerPort --name containerName used Image potentialCOMMAND`


### Basic Docker Containers Management

Inside of a container created with Docker, applications and commands can be used in an isolated environment. For example, you can check that, 1) the environment variables existing in the running docker container are isolated and specifically designed for this environment and 2) a file created in a Docker container will only exist in this container.

#### Bridges

Docker installed a Linux bridge docker0 in your system. This bridge can be analysed using the following command: `docker network inspect bridge`

In a default configuration, all docker containers launched on a machine are attached to this bridge.

Launch two containers with the `debian:stretch` image.

**Q2. Can containers ping each other: 1) using IP adresses? 2) using their hostname?**

(Note: containers hostname can be displayed within containers using `echo $HOSTNAME`)

Now, stop and delete container2 and restart it with the following command (*using correct naming for containers!)*:
```console
$ docker run -ti --name XXX2 --link XXX1 debian:stretch
```

*Note: You can also create custom bridged networks: https://docs.docker.com/network/bridge/*

**Q3. Can containers ping each other using their hostname now?**

#### Ports Exposure

The idea, in this small example will be to access a web server runnin within a container. To enable that, it will be required to make the containers ports public (expose them).

To do so, you will have to install the `netcat-openbsd` package.

For example, what should do the following command line? (`while true;do echo ok |nc -l 8080; done;`)

**Q4. If you launch the three different command lines what will be the different between the outputs of a docker ps? How container could be reachable?**

  1. `docker run --name test1 -d debian:stretch /bin/bash -c 'while true;\ do echo ok |nc -l 8080; done;'`
  2. `docker run -p 8080 --name test1 -d debian:stretch /bin/bash -c \ 'while true; do echo ok |nc -l 8080; done;'`
  3. `docker run -p 8080:8080 --name test1 -d debian:stretch /bin/bash -c \ 'while true; do echo ok |nc -l 8080; done;'`

#### Own Docker Image Using Docker File

Creating a new docker image is possible using the following procedure:
  1. Create a new directory and do within this directory
  2. Within this directory, create a new file called `Dockerfile`
  3. Add the following content to this file:
```console
FROM debian:stretch
RUN apt-get -y update && apt-get install -y iperf netcat-openbsd iputils-ping
CMD iperf -s
```
**Q5. What does the program seem to do?**
  4. Within your folder, you can new build your Docker image using the following command line: `docker build -t iperf-serv .` You can verify that your image has been generated using the following command: `docker images`
  5. To run this image you can simply use: `docker run -ti iperf-serv` 

#### Persistent data storage

Persistent data storage can be managed using two approaches: 1) images commit (cf. first subsection of section 1) 2) using volumes.

For example, if you 1) launch a docker container using a pre-build image (`docker run... debian:stretch...`), 2) create a new file within this docker container and add content to this file, 3) exit the docker container and remote it (`docker rm`) and 4) run it again (back to the first step of this procedure).

**Q6. Is the file that you created earlier still existing? Why data persistence is an important point?**

Volumes are directories in the host that are mapped to directories in containers. 

Using the `--mount` or the `-v` flag, mount the host directory `allData` in the container directory `/mydata`. Verify that it works.

**Q.7 What is the main difference between bind mounts and bien volumes?**

(Possible source: https://stackoverflow.com/questions/69496662/are-bind-mounts-and-host-volumes-the-same-thing-in-docker)

## 2. Implementing a new application

### Basic (Static) Web Server Image deployment

*Note: DockerFile can potentially used there but it is not required*

For this part, using the previous sections, follow the different steps:
  1. Download the Debian (stretch) image
  2. Run this container with an interactive shell naming it "serverV0"
  3. Update packages within this container (apt-get update && apt-get upgrade)
  4. Update date within this container: `dpkg-reconfigure tzdata`
  5. Install apache2 within this container
  6. Commit a new image based on this evolved container naming it my/debian:stretch-apache2
  
Then, you should be able to launch container using this new image:

```console
docker run -d -p 127.0.0.1:8001:80 --name contX my/debian:stretch-apache2 /usr/sbin/apache2ctl -DFOREGROUND
```

That happens of you go on a browser (on your own client) and connect to the following URL: `http://127.0.0.1:8001`?

**Q8. What is Apache? What can it be used for? What are the main elements of the above command line?**

### Evolved (Dynamic) Web Server Image deployment

#### Server Side

For this part, you will first start with differents steps similar to the first task:
  1. Run a container based on the image that you commited with an interactive shell naming it "serverV1"
  2. Install php7.0 and php7.0-mysql on your container
  3. Commit a new image based on this container.
  
Create on the host the folder `/var/www/html_docker` and drop the source files of the application in it. These source files correspond to the content of the getstages folder (accessible in this github page).

Now, run a container using this new image and enabling you to access the Web App. The following command could be used: `docker run --name servweb -d 'persistent storage flag' -p 127.0.0.1:hostPort:80  used-Imaged /usr/sbin/apache2ctl  -DFOREGROUND`

What happens if you connect to `http://IPAdresse:Port/geststages/`?

#### Database Side

We will now try to link this web application to the database it runs. The MariaDB database management system (free fork of MySQL) will be in its own container and access to the database will only be possible from the application integrated in the apache/PHP container. Thus, each service (app, database) is implemented in an independent container. The idea is to provide atomic services.

As an example to start this section: 1) dowload the mariabd image and run it using the following command line:

```console
docker run -p 3306:3306 -v /var/lib/mysql_docker:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=mysqlAdmin --name servdb -d mariadb
```
**Q.9. What does this line seem to do?**

In another terminal you can veriyh that you are able to access this db:
```console
mysql -u root -p -h 127.0.0.1
root
mysqlAdmin
```

Note: Default user (root) and default password (mysqlAdmin) are used there.

We will now try to interconnect a real DB to our Web App.

The database that will be used in this practical exercise can be retrieved there (you need to retrieve that!): https://drive.google.com/file/d/1BGPzQvK4YYjErqT9jwBpv2XSqyfEpOVj/view?usp=sharing

Since the objective is to connect the website of the apache/PHP container to the database, it is not useful to make the database visible to clients outside the host machine or another docker container containing an application intended to exploit this database. By default, when a container is started from the mariadb image, port 3306 is open (it is "exposed"). Simply create a link (-link) between the two containers that uses this exposed port by default. Thus, the web application has access to the "bdd_geststages" database with the user "usergs" who has the password "mdpGS". These are the elements that are created when the SQL file is imported. Furthermore, the database is accessed on the host "servdb" ⇒ If you have followed the instructions, you have theoretically named the original container with this name, otherwise you must use this name as an alias in the command for launching the container.

Stop and delete the previously created servdb container. Create a new servdb container without port forwarding and test access from another instance of the mariadb image. (**You will have to put the sql file in the right folder !**)

This could potentially be doce with a line such as this one:

```console
docker run -it --rm --link servdb:clientmariadb mariadb bash -c 'exec mysql -h "$CLIENTMARIADB_PORT_3306_TCP_ADDR" -u root -pmysqlAdmin’
```

The script for initializing the database is provided: geststages.sql. It includes all the necessary elements (creation of the database, of the user having the rights on the database, of the tables, of the constraints as well as the SQL commands for inserting the data). We can see that the Web application has access to the database "bdd_geststages" with the user "usergs" who has the password "mdpGS". At the application level, the access to the database is configured in "include/function/f_bdd.php".

Use an instance of the mariadb image to initialize the database. The script "geststages.sql" will be dropped in the folder "/mnt/scripts" of the host (folder mapped to the "scripts" folder of the container). 

Following command lives could be used:

```console
mkdir /mnt/scripts
mv  geststages.sql /mnt/scripts
docker run -it --rm --link servdb:clientmariadb -v /mnt/scripts:/scripts mariadb bash -c 'exec mysql -h "$CLIENTMARIADB_PORT_3306_TCP_ADDR" -u root -pmysqlAdmin < /scripts/geststages.sql’
```

Stop and delete the Web Server previously ran in this section and launch a new one linked to the container including the database:

```console
docker run --name servweb -d --link servdb:servmariadb -v /var/www/html_docker:/var/www/html -p 127.0.0.1:hostPort:80 XXX:stretch-apache2-php7 /usr/sbin/apache2ctl -DFOREGROUND
```
You should now be able to verify if the whole process worked in the Web Browser! For the authentication on the application, the login and the passwords are voluntarily in clear text in the database (tables "student" and "teacher"). You can test the connection with the student "benpas01" who has the password "benpas01".

### Using Docker Compose to Launch Apps

In the previous task, running the "geststages" web application required the use and launch of two two containers. In a "microservices" architecture, this situation is very common with many more containers and the commands to launch them are sometimes very long and complicated.

The Docker Compose technology will allow us to focus only on the definition of the architecture, and to leave the management of the scripts to the tool. A docker-compose.yml file will contain the list of containers with their links, their image, the definition of ports, etc. The docker-compose command will allow us to control in a single command line the running of all the containers described in this file, their stopping, etc.

Docker Compose is a tool that allows (among other things) to describe, manage and start multiple containers (and the links between them) that make up a single application in an isolated and secure isolated and secure environment.

Typically, Docker Compose allows the definition of the application architecture and the very simple orchestration of containers by:
  - defining all the services that compose an application in a YAML file file "docker-compose.yml" to run them together in an isolated environment;
  - allowing to get a running application in a single command (docker-compose up).
This will give us the possibility, from a single command, to create and start all the services necessary for the functioning of our application "geststages".

Note that Docker Compose is provided by the Docker developers but is not included in basic package installation. You can use the following documentation to install it: https://docs.docker.com/compose/install/linux/. A potentially working procedure is also proposed in the `install_docker_compose.sh` file.

An example of a Docker Compose File can be found there: https://github.com/OCSInventory-NG/OCSInventory-Docker-Stack/blob/master/docker-compose.yml

Based on this example, you will have to use Docker Compose to deploy our getstages web app.

To achieve that, you fill first have to create a folder (named for example docker-stack) with the following tree structure:
  - a docker-compose.yml file
  - a initSQL folder containing the previously considered DB
  - a PHP folder containing the Web App Sources
  
Two containers will have to be created there within the Docker Compose file : web and servdb. As a reminder, the web application has access to the "bdd_geststages" database with the user "usergs" who has the password "mdpGS". These elements are created when the SQL file is imported.

Regarding the web app:
  1. it is based on the last image commited (including phd and apache);
  2. The "PHP" folder will be mapped to "/var/www/html";
  3. The "apache" service must be started (/usr/sbin/apache2ctl -DFOREGROUND).
  
Regarding the DB:
  1. Based on the mariadb image
  2. The "initSQL" folder will be mapped to /docker-entrypoint-initdb.d. The "mariadb" image provides, at the container startup, the execution of the "entrypoint.sh" file (present at the root of the container) which, in turn, loads all the scripts of the /docker-entrypoint-initdb.d directory;
  3. A "mysqldata" volume will be provided to permanently store the data in the database (persistence);
  4. Access to the database server must be accessible via port 3306 only by the application. This port is exposed at the image level, so there is no need to redirect to the host;
  5. Only the password of the mysql root user needs to be set.

Using the exemple (OCSI Inventory), try to complete the DockerCompose file located in the docker-stack folder.

You should then be able to lauch containers and verify that the Web App operates in an effective way (ie you should be able to connect to and to use the Web App).

Note, using the `docker-compose` command line, the following command should be used to run apps: `docker-compose up -d`. Main docker commands could also be used using the docker-compose command to start/restart/stop containers. You can, for exemple si the list of running services: `docker-compose ps`. Classical docker commands could also be executed such as `docker exec -it ocsinventory-server bash `.


